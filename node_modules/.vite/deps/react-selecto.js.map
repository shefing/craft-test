{
  "version": 3,
  "sources": ["../../keycon/src/utils.ts", "../../keycon/src/KeyController.ts", "../../keycon/src/reactive.ts", "../../selecto/src/utils.ts", "../../selecto/src/consts.ts", "../../selecto/src/SelectoManager.tsx", "../../selecto/src/Selecto.tsx", "../../react-selecto/src/react-selecto/consts.ts", "../../react-selecto/src/react-selecto/Selecto.tsx"],
  "sourcesContent": ["import { names } from \"keycode\";\n\nconst codeData = {\n    \"+\": \"plus\",\n    \"left command\": \"meta\",\n    \"right command\": \"meta\",\n};\nconst keysSort = {\n    shift: 1,\n    ctrl: 2,\n    alt: 3,\n    meta: 4,\n};\n\n/**\n * @memberof KeyController\n */\nexport function getKey(keyCode: number, keyName?: string): string {\n    let key = (names[keyCode] || keyName || \"\").toLowerCase();\n\n    for (const name in codeData) {\n        key = key.replace(name, codeData[name]);\n    }\n    return key.replace(/\\s/g, \"\");\n}\n\n/**\n * @memberof KeyController\n */\nexport function getCombi(e: KeyboardEvent, key: string = getKey(e.keyCode, e.key)): string[] {\n    const keys = getModifierCombi(e);\n    keys.indexOf(key) === -1 && keys.push(key);\n\n    return keys.filter(Boolean);\n}\n\n/**\n * @memberof KeyController\n */\nexport function getModifierCombi(e: KeyboardEvent): string[] {\n    const keys = [e.shiftKey && \"shift\", e.ctrlKey && \"ctrl\", e.altKey && \"alt\", e.metaKey && \"meta\"];\n\n    return keys.filter(Boolean);\n}\n\n/**\n * @memberof KeyController\n */\nexport function getArrangeCombi(keys: string[]) {\n    const arrangeKeys = keys.slice();\n    arrangeKeys.sort((prev, next) => {\n        const prevScore = keysSort[prev] || 5;\n        const nextScore = keysSort[next] || 5;\n\n        return prevScore - nextScore;\n    });\n\n    return arrangeKeys;\n}\n", "import EventEmitter, { EmitterParam, TargetParam } from \"@scena/event-emitter\";\n\nimport { isString, isArray, addEvent, removeEvent } from \"@daybrush/utils\";\nimport { getArrangeCombi, getKey, getCombi } from \"./utils\";\n\n/**\n * @typedef\n * @memberof KeyController\n */\nexport interface KeyControllerEvent extends EmitterParam {\n    inputEvent: KeyboardEvent;\n    isToggle: boolean;\n    key: string;\n    keyCode: number;\n    ctrlKey: boolean;\n    altKey: boolean;\n    shiftKey: boolean;\n    metaKey: boolean;\n}\n\nexport interface OnKeydown extends KeyControllerEvent {\n\n}\nexport interface OnKeyup extends KeyControllerEvent {\n\n}\nexport interface OnBlur {\n\n}\nexport interface KeyconEvents {\n    keydown: OnKeydown;\n    keyup: OnKeyup;\n    blur: OnBlur;\n}\nexport type KeyControllerEvents = KeyconEvents;\n\nlet globalKeyController!: KeyController;\n\n/**\n */\nclass KeyController extends EventEmitter<KeyconEvents & { [text: string]: any }> {\n    /**\n     */\n    public static get global() {\n        return globalKeyController || (globalKeyController = new KeyController());\n    }\n    public static setGlobal() {\n        return this.global;\n    }\n    /**\n     */\n    public ctrlKey = false;\n    /**\n     */\n    public altKey = false;\n    /**\n     *\n     */\n    public shiftKey = false;\n    /**\n     *\n     */\n    public metaKey = false;\n    /**\n     *\n     */\n    constructor(public container: Window | Document | HTMLElement = window) {\n        super();\n\n        addEvent(container, \"blur\", this.blur);\n        addEvent(container, \"keydown\", this.keydownEvent);\n        addEvent(container, \"keyup\", this.keyupEvent);\n    }\n    public clear = (): this => {\n        this.ctrlKey = false;\n        this.altKey = false;\n        this.shiftKey = false;\n        this.metaKey = false;\n        return this;\n    }\n    /**\n     *\n     */\n    public destroy() {\n        const container = this.container as any;\n\n        this.clear();\n        this.off();\n        removeEvent(container, \"blur\", this.blur);\n        removeEvent(container, \"keydown\", this.keydownEvent);\n        removeEvent(container, \"keyup\", this.keyupEvent);\n    }\n    public keydown(comb: string | string[], callback: (e: KeyControllerEvent) => void): this;\n    public keydown(callback: (e: KeyControllerEvent) => void): this;\n    /**\n     *\n     */\n    public keydown(\n        comb: string | string[] | ((e: KeyControllerEvent) => void),\n        callback?: (e: KeyControllerEvent) => void,\n    ): this {\n        return this.addEvent(\"keydown\", comb, callback);\n    }\n    public offKeydown(comb: string | string[], callback?: (e: KeyControllerEvent) => void): this;\n    public offKeydown(callback: (e: KeyControllerEvent) => void): this;\n    /**\n     *\n     */\n    public offKeydown(\n        comb: string | string[] | ((e: KeyControllerEvent) => void),\n        callback?: (e: KeyControllerEvent) => void,\n    ): this {\n        return this.removeEvent(\"keydown\", comb, callback);\n    }\n    public offKeyup(comb: string | string[], callback?: (e: KeyControllerEvent) => void): this;\n    public offKeyup(callback: (e: KeyControllerEvent) => void): this;\n    /**\n     *\n     */\n    public offKeyup(\n        comb: string | string[] | ((e: KeyControllerEvent) => void),\n        callback?: (e: KeyControllerEvent) => void,\n    ): this {\n        return this.removeEvent(\"keyup\", comb, callback);\n    }\n    public keyup(comb: string | string[], callback: (e: KeyControllerEvent) => void): this;\n    public keyup(callback: (e: KeyControllerEvent) => void): this;\n    /**\n     *\n     */\n    public keyup(\n        comb: string | string[] | ((e: KeyControllerEvent) => void),\n        callback?: (e: KeyControllerEvent) => void,\n    ): this {\n        return this.addEvent(\"keyup\", comb, callback);\n    }\n    private addEvent(\n        type: \"keydown\" | \"keyup\",\n        comb: string | string[] | ((e: KeyControllerEvent) => void),\n        callback?: (e: KeyControllerEvent) => void,\n    ) {\n        if (isArray(comb)) {\n            this.on(`${type}.${getArrangeCombi(comb).join(\".\")}`, callback);\n        } else if (isString(comb)) {\n            this.on(`${type}.${comb}`, callback);\n        } else {\n            this.on(type, comb);\n        }\n        return this;\n    }\n    private removeEvent(\n        type: \"keydown\" | \"keyup\",\n        comb: string | string[] | ((e: KeyControllerEvent) => void) | undefined,\n        callback?: (e: KeyControllerEvent) => void,\n    ) {\n        if (isArray(comb)) {\n            this.off(`${type}.${getArrangeCombi(comb).join(\".\")}`, callback);\n        } else if (isString(comb)) {\n            this.off(`${type}.${comb}`, callback);\n        } else {\n            this.off(type, comb);\n        }\n        return this;\n    }\n    private triggerEvent(type: \"keydown\" | \"keyup\", e: KeyboardEvent) {\n        this.ctrlKey = e.ctrlKey;\n        this.shiftKey = e.shiftKey;\n        this.altKey = e.altKey;\n        this.metaKey = e.metaKey;\n\n        const key = getKey(e.keyCode, e.key);\n        const isToggle = key === \"ctrl\"\n            || key === \"shift\"\n            || key === \"meta\"\n            || key === \"alt\";\n        const param: TargetParam<KeyControllerEvent> = {\n            key,\n            isToggle,\n            inputEvent: e,\n            keyCode: e.keyCode,\n            ctrlKey: e.ctrlKey,\n            altKey: e.altKey,\n            shiftKey: e.shiftKey,\n            metaKey: e.metaKey,\n        };\n        this.trigger(type, param);\n        this.trigger(`${type}.${key}`, param);\n\n        const combi = getCombi(e, key);\n\n        combi.length > 1 && this.trigger(`${type}.${combi.join(\".\")}`, param);\n    }\n    private keydownEvent = (e: KeyboardEvent) => {\n        this.triggerEvent(\"keydown\", e);\n    }\n    private keyupEvent = (e: KeyboardEvent) => {\n        this.triggerEvent(\"keyup\", e);\n    }\n    private blur = () => {\n        this.clear();\n        this.trigger(\"blur\");\n    }\n}\n\nexport default KeyController;\n", "import { ReactiveAdapter, reactive, Ref, observe, ReactiveObject, Observer } from \"@cfcs/core\";\nimport KeyController, { KeyControllerEvents, KeyControllerEvent } from \"./KeyController\";\n\nexport interface ReactiveKeyControllerData {\n    ref?: Ref<HTMLElement | null | undefined>;\n    checker?: (e: KeyControllerEvent) => boolean;\n    keys: string | string[];\n}\n\nexport type ReactiveKeyController = ReactiveObject<{\n    inst: KeyController;\n    keys: string | string[];\n    isKeydown: Observer<boolean>;\n    destroy(): void;\n}>;\n\nlet instanceMap!: Map<HTMLElement | Window | Document, {\n    inst: KeyController;\n    count: number;\n}>;\n\nexport const REACTIVE: ReactiveAdapter<\n    ReactiveKeyController,\n    { isKeydown: boolean },\n    never,\n    ReactiveKeyControllerData,\n    KeyControllerEvents\n> = {\n    events: [\"keydown\", \"keyup\", \"blur\"],\n    state: { isKeydown: false },\n    mounted(data) {\n        if (!instanceMap) {\n            instanceMap = new Map();\n        }\n        const element = data.ref?.current ?? window;\n\n        let info = instanceMap.get(element);\n\n        if (!info) {\n            info = {\n                inst: new KeyController(element),\n                count: 0,\n            };\n\n            instanceMap.set(element, info);\n        }\n        ++info.count;\n\n        const keycon = info.inst;\n        const keys = data.keys;\n        const isKeydown = observe(false);\n        const checker = data.checker;\n\n        keycon.keydown(keys, (e: KeyControllerEvent) => {\n            if (!checker || checker(e)) {\n                isKeydown.current = true;\n            }\n        });\n        keycon.keyup(keys, () => {\n            isKeydown.current = false;\n        });\n        keycon.on(\"blur\", () => {\n            isKeydown.current = false;\n        });\n\n        return reactive({\n            inst: keycon,\n            keys,\n            destroy: () => keycon.destroy(),\n            isKeydown,\n        });\n    },\n    destroy({ inst }) {\n        const element = inst.container;\n        const info = instanceMap.get(element);\n\n        --info.count;\n        if (!info.count) {\n            inst.destroy();\n            instanceMap.delete(element);\n        }\n    },\n    on(inst, name, callback) {\n        const keycon = inst.inst;\n\n        if (name === \"keydown\") {\n            keycon.keydown(inst.keys, callback as any);\n        } else if (name === \"keyup\") {\n            keycon.keyup(inst.keys, callback as any);\n        } else {\n            keycon.on(name, callback as any);\n        }\n    },\n    off(inst, name, callback) {\n        const keycon = inst.inst;\n\n        if (name === \"keydown\") {\n            keycon.offKeydown(inst.keys, callback as any);\n        } else if (name === \"keyup\") {\n            keycon.offKeyup(inst.keys, callback as any);\n        } else {\n            keycon.off(name, callback as any);\n        }\n    },\n}\n", "import type { ElementType, Hypertext, Point, Rect } from \"./types\";\nimport { IObject, addClass, hasClass, calculateBoundSize, getDist, getDocument } from \"@daybrush/utils\";\nimport { diff } from \"@egjs/children-differ\";\nimport { getMinMaxs } from \"overlap-area\";\n\nexport function getClient(e: MouseEvent | TouchEvent) {\n    if (\"touches\" in e) {\n        const touch = e.touches[0] || e.changedTouches[0];\n\n        return {\n            clientX: touch.clientX,\n            clientY: touch.clientY,\n        };\n    } else {\n        return {\n            clientX: e.clientX,\n            clientY: e.clientY,\n        };\n    }\n}\nexport function filterDuplicated<T>(arr: T[]): T[] {\n    if (typeof Map === \"undefined\") {\n        return arr.filter((value, index) => {\n            return arr.indexOf(value) === index;\n        });\n    }\n    const map = new Map<T, true>();\n    return arr.filter(value => {\n        if (map.has(value)) {\n            return false;\n        }\n        map.set(value, true);\n        return true;\n    });\n}\n\nexport function elementFromPoint(baseNode: Node, clientX: number, clientY: number): ElementType | null {\n    const doc = getDocument(baseNode);\n\n    return (doc.elementFromPoint && doc.elementFromPoint(clientX, clientY)) as any || null;\n}\n\nexport function createElement(\n    jsx: Hypertext,\n    prevTarget?: ElementType,\n    container?: ElementType,\n) {\n    const { tag, children, attributes, className, style } = jsx;\n    const el = prevTarget || getDocument(container).createElement(tag) as ElementType;\n\n    for (const name in attributes) {\n        el.setAttribute(name, attributes[name]);\n    }\n    const elChildren = el.children;\n    children.forEach((child, i) => {\n        createElement(child, elChildren[i] as ElementType, el);\n    });\n    if (className) {\n        className.split(/\\s+/g).forEach(name => {\n            if (name && !hasClass(el, name)) {\n                addClass(el, name);\n            }\n        });\n    }\n    if (style) {\n        const elStyle = el.style;\n        for (const name in style) {\n            elStyle[name] = style[name];\n        }\n    }\n    if (!prevTarget && container) {\n        container.appendChild(el);\n    }\n    return el;\n}\nexport function h(\n    tag: string,\n    attrs: IObject<any>,\n    ...children: Hypertext[]\n): Hypertext {\n    const {\n        className = \"\",\n        style = {},\n        ...attributes\n    } = attrs || {};\n    return {\n        tag,\n        className,\n        style,\n        attributes,\n        children,\n    };\n}\n\nexport function diffValue<T>(prev: T, cur: T, func: (prev: T, cur: T) => void) {\n    if (prev !== cur) {\n        func(prev, cur);\n    }\n}\nexport function isFastInside(point: number[], points: number[][]) {\n    const { minX, minY, maxX, maxY } = getMinMaxs(points);\n    const [x, y] = point;\n\n    return minX <= x && x <= maxX && minY <= y && y <= maxY;\n}\nexport function getFastOverlapPoints(points1: number[][], points2: number[][]) {\n    const {\n        minX: minX1,\n        minY: minY1,\n        maxX: maxX1,\n        maxY: maxY1,\n    } = getMinMaxs(points1);\n    const {\n        minX: minX2,\n        minY: minY2,\n        maxX: maxX2,\n        maxY: maxY2,\n    } = getMinMaxs(points2);\n\n    if (maxX2 < minX1 || maxX1 < minX2 || maxY2 < minY1 || maxY1 < minY2) {\n        return [];\n    }\n    const width = Math.min(maxX2 - minX1, maxX1 - minX2);\n    const height = Math.min(maxY2 - minY1, maxY1 - minY2);\n\n    return [\n        [0, 0],\n        [width, 0],\n        [width, height],\n        [0, height],\n    ];\n}\nexport function getRect(\n    e: any, ratio: number,\n    boundArea = e.data.boundArea,\n): Rect {\n    let {\n        distX = 0,\n        distY = 0,\n    } = e;\n    const { startX, startY } = e.data;\n\n    if (ratio > 0) {\n        const nextHeight = Math.sqrt((distX * distX + distY * distY) / (1 + ratio * ratio));\n        const nextWidth = ratio * nextHeight;\n\n        distX = (distX >= 0 ? 1 : -1) * nextWidth;\n        distY = (distY >= 0 ? 1 : -1) * nextHeight;\n    }\n    let width = Math.abs(distX);\n    let height = Math.abs(distY);\n\n    const maxWidth = distX < 0 ? startX - boundArea.left : boundArea.right - startX;\n    const maxHeight = distY < 0 ? startY - boundArea.top : boundArea.bottom - startY;\n\n    [width, height] = calculateBoundSize([width, height], [0, 0], [maxWidth, maxHeight], !!ratio);\n    distX = (distX >= 0 ? 1 : -1) * width;\n    distY = (distY >= 0 ? 1 : -1) * height;\n\n    const tx = Math.min(0, distX);\n    const ty = Math.min(0, distY);\n    const left = startX + tx;\n    const top = startY + ty;\n\n    return {\n        left,\n        top,\n        right: left + width,\n        bottom: top + height,\n        width,\n        height,\n    };\n}\n\nexport function getDefaultElementRect(el: ElementType): Point {\n    const rect = el.getBoundingClientRect();\n    const { left, top, width, height } = rect;\n\n    return {\n        pos1: [left, top],\n        pos2: [left + width, top],\n        pos3: [left, top + height],\n        pos4: [left + width, top + height],\n    };\n}\n\nexport function passTargets(\n    beforeTargets: ElementType[],\n    afterTargets: ElementType[],\n    continueSelectWithoutDeselect: boolean,\n) {\n    const {\n        list,\n        prevList,\n        added,\n        removed,\n        maintained,\n    } = diff(beforeTargets, afterTargets);\n\n    return [\n        ...added.map(index => list[index]),\n        ...removed.map(index => prevList[index]),\n        ...continueSelectWithoutDeselect ? maintained.map(([, nextIndex]) => list[nextIndex]) : [],\n    ];\n}\n\nexport function getLineSize(points: number[][]) {\n    let size = 0;\n    const length = points.length;\n\n    for (let i = 1; i < length; ++i) {\n        size = Math.max(getDist(points[i], points[i - 1]), size);\n    }\n\n    return size;\n}\n", "import styled from \"css-styled\";\nimport { SelectoOptions } from \"./types\";\n\nexport const injector = styled(`\n:host {\n    position: fixed;\n    display: none;\n    border: 1px solid #4af;\n    background: rgba(68, 170, 255, 0.5);\n    pointer-events: none;\n    will-change: transform;\n    z-index: 100;\n}\n`);\n\n/**\n * @memberof Selecto\n */\nexport const CLASS_NAME = `selecto-selection ${injector.className}`;\n\nexport const PROPERTIES = [\n    \"className\",\n    \"boundContainer\",\n    \"selectableTargets\",\n    \"selectByClick\",\n    \"selectFromInside\",\n    \"continueSelect\",\n    \"continueSelectWithoutDeselect\",\n    \"toggleContinueSelect\",\n    \"toggleContinueSelectWithoutDeselect\",\n    \"keyContainer\",\n    \"hitRate\",\n    \"scrollOptions\",\n    \"checkInput\",\n    \"preventDefault\",\n    \"ratio\",\n    \"getElementRect\",\n    \"preventDragFromInside\",\n    \"rootContainer\",\n    \"dragCondition\",\n    \"clickBySelectEnd\",\n    \"checkOverflow\",\n    \"innerScrollOptions\",\n] as const;\n/**\n * @memberof Selecto\n */\nexport const OPTIONS = [\n    // ignore target, container,\n    \"dragContainer\",\n    \"cspNonce\",\n    \"preventClickEventOnDrag\",\n    \"preventClickEventOnDragStart\",\n    \"preventRightClick\",\n    ...PROPERTIES,\n] as const;\n\nexport const OPTION_TYPES: { [key in keyof SelectoOptions]: any } = {\n    className: String,\n    boundContainer: null,\n    portalContainer: null,\n    container: null,\n    dragContainer: null,\n    selectableTargets: Array,\n    selectByClick: Boolean,\n    selectFromInside: Boolean,\n    continueSelect: Boolean,\n    toggleContinueSelect: Array,\n    toggleContinueSelectWithoutDeselect: Array,\n    keyContainer: null,\n    hitRate: Number,\n    scrollOptions: Object,\n    checkInput: Boolean,\n    preventDefault: Boolean,\n    cspNonce: String,\n    ratio: Number,\n    getElementRect: Function,\n    preventDragFromInside: Boolean,\n    rootContainer: Object,\n    dragCondition: Function,\n    clickBySelectEnd: Boolean,\n    continueSelectWithoutDeselect: Boolean,\n    preventClickEventOnDragStart: Boolean,\n    preventClickEventOnDrag: Boolean,\n    checkOverflow: Boolean,\n    innerScrollOptions: Object,\n};\n\n/**\n * @memberof Selecto\n */\nexport const EVENTS = [\n    \"dragStart\",\n    \"drag\",\n    \"dragEnd\",\n    \"selectStart\",\n    \"select\",\n    \"selectEnd\",\n    \"keydown\",\n    \"keyup\",\n    \"scroll\",\n    \"innerScroll\",\n] as const;\n\n/**\n * @memberof Selecto\n */\nexport const METHODS = [\n    \"clickTarget\",\n    \"getSelectableElements\",\n    \"setSelectedTargets\",\n    \"getElementPoints\",\n    \"getSelectedTargets\",\n    \"findSelectableTargets\",\n    \"triggerDragStart\",\n    \"checkScroll\",\n    \"selectTargetsByPoints\",\n    \"setSelectedTargetsByPoints\",\n] as const;\n", "import EventEmitter from \"@scena/event-emitter\";\nimport Gesto, { OnDrag } from \"gesto\";\nimport { InjectResult } from \"css-styled\";\nimport { Properties } from \"framework-utils\";\nimport {\n    isObject,\n    camelize,\n    IObject,\n    addEvent,\n    removeEvent,\n    isArray,\n    isString,\n    between,\n    splitUnit,\n    isFunction,\n    getWindow,\n    getDocument,\n    isNode,\n} from \"@daybrush/utils\";\nimport { diff } from \"@egjs/children-differ\";\nimport DragScroll from \"@scena/dragscroll\";\nimport KeyController, { KeyControllerEvent, getCombi } from \"keycon\";\nimport {\n    getAreaSize,\n    getOverlapPoints,\n    isInside,\n    fitPoints,\n} from \"overlap-area\";\nimport { getDistElementMatrix, calculateMatrixDist, createMatrix } from \"css-to-mat\";\nimport {\n    createElement,\n    h,\n    getClient,\n    diffValue,\n    getRect,\n    getDefaultElementRect,\n    passTargets,\n    elementFromPoint,\n    filterDuplicated,\n    getLineSize,\n} from \"./utils\";\nimport {\n    SelectoOptions,\n    SelectoProperties,\n    OnDragEvent,\n    SelectoEvents,\n    Rect,\n    BoundContainer,\n    SelectedTargets,\n    SelectedTargetsWithRect,\n    InnerParentInfo,\n    ElementType,\n    OnDragStart,\n} from \"./types\";\nimport { PROPERTIES, injector, CLASS_NAME } from \"./consts\";\n\n/**\n * Selecto.js is a component that allows you to select elements in the drag area using the mouse or touch.\n * @sort 1\n * @extends EventEmitter\n */\n@Properties(PROPERTIES as any, (prototype, property) => {\n    const attributes: IObject<any> = {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return this.options[property];\n        },\n    };\n    const getter = camelize(`get ${property}`);\n    if (prototype[getter]) {\n        attributes.get = function() {\n            return this[getter]();\n        };\n    } else {\n        attributes.get = function() {\n            return this.options[property];\n        };\n    }\n    const setter = camelize(`set ${property}`);\n    if (prototype[setter]) {\n        attributes.set = function(value: any) {\n            this[setter](value);\n        };\n    } else {\n        attributes.set = function(value: any) {\n            this.options[property] = value;\n        };\n    }\n    Object.defineProperty(prototype, property, attributes);\n})\n\nclass Selecto extends EventEmitter<SelectoEvents> {\n    public options: SelectoOptions;\n    private target!: ElementType;\n    private dragContainer!: Element | Window | Element[];\n    private container!: HTMLElement;\n    private gesto!: Gesto;\n    private injectResult!: InjectResult;\n    private selectedTargets: ElementType[] = [];\n    private dragScroll: DragScroll = new DragScroll();\n    private keycon!: KeyController;\n    private _keydownContinueSelect: boolean;\n    private _keydownContinueSelectWithoutDeselection: boolean;\n    /**\n     *\n     */\n    constructor(options: Partial<SelectoOptions> = {}) {\n        super();\n        this.target = options.portalContainer;\n        let container = options.container;\n        this.options = {\n            className: \"\",\n            portalContainer: null,\n            container: null,\n            dragContainer: null,\n            selectableTargets: [],\n            selectByClick: true,\n            selectFromInside: true,\n            clickBySelectEnd: false,\n            hitRate: 100,\n            continueSelect: false,\n            continueSelectWithoutDeselect: false,\n            toggleContinueSelect: null,\n            toggleContinueSelectWithoutDeselect: null,\n            keyContainer: null,\n            scrollOptions: null,\n            checkInput: false,\n            preventDefault: false,\n            boundContainer: false,\n            preventDragFromInside: true,\n            dragCondition: null,\n            rootContainer: null,\n            checkOverflow: false,\n            innerScrollOptions: false,\n            getElementRect: getDefaultElementRect,\n            cspNonce: \"\",\n            ratio: 0,\n            ...options,\n        };\n        const portalContainer = this.options.portalContainer;\n\n        if (portalContainer) {\n            container = portalContainer.parentElement;\n        }\n        this.container = container || document.body;\n        this.initElement();\n        this.initDragScroll();\n        this.setKeyController();\n    }\n    /**\n     * You can set the currently selected targets.\n     * selectByClick, continueSelect, and continueSelectWithoutDeselect are not applied.\n     */\n    public setSelectedTargets(\n        selectedTargets: ElementType[],\n    ): SelectedTargets {\n        const beforeSelected = this.selectedTargets;\n        const { added, removed, prevList, list } = diff(\n            beforeSelected,\n            selectedTargets\n        );\n        this.selectedTargets = selectedTargets;\n\n        return {\n            added: added.map(index => list[index]),\n            removed: removed.map(index => prevList[index]),\n            beforeSelected,\n            selected: selectedTargets,\n        };\n    }\n    /**\n     * You can set the currently selected targets by points\n     * selectByClick, continueSelect, and continueSelectWithoutDeselect are not applied.\n     */\n    public setSelectedTargetsByPoints(\n        point1: number[],\n        point2: number[],\n    ): SelectedTargetsWithRect {\n        const left = Math.min(point1[0], point2[0]);\n        const top = Math.min(point1[1], point2[1]);\n        const right = Math.max(point1[0], point2[0]);\n        const bottom = Math.max(point1[1], point2[1]);\n        const rect: Rect = {\n            left,\n            top,\n            right,\n            bottom,\n            width: right - left,\n            height: bottom - top,\n        };\n        const data = { ignoreClick: true };\n\n        this.findSelectableTargets(data);\n        const selectedElements = this.hitTest(rect, data, true, null);\n        const result = this.setSelectedTargets(selectedElements);\n\n        return {\n            ...result,\n            rect,\n        };\n    }\n    /**\n     * Select target by virtual drag from startPoint to endPoint.\n     * The target of inputEvent is null.\n     */\n    public selectTargetsByPoints(\n        startPoint: number[],\n        endPoint: number[],\n    ) {\n        const mousedown = new MouseEvent(\"mousedown\", {\n            clientX: startPoint[0],\n            clientY: startPoint[1],\n            cancelable: true,\n            bubbles: true,\n        });\n        const mousemove = new MouseEvent(\"mousemove\", {\n            clientX: endPoint[0],\n            clientY: endPoint[1],\n            cancelable: true,\n            bubbles: true,\n        });\n        const mouseup = new MouseEvent(\"mousemove\", {\n            clientX: endPoint[0],\n            clientY: endPoint[1],\n            cancelable: true,\n            bubbles: true,\n        });\n        const gesto = this.gesto;\n        const result = gesto.onDragStart(mousedown);\n\n        if (result !== false) {\n            gesto.onDrag(mousemove);\n            gesto.onDragEnd(mouseup);\n        }\n    }\n    /**\n     * You can get the currently selected targets.\n     */\n    public getSelectedTargets(): ElementType[] {\n        return this.selectedTargets;\n    }\n    /**\n     * `OnDragStart` is triggered by an external event.\n     * @param - external event\n     * @example\n     * import Selecto from \"selecto\";\n     *\n     * const selecto = new Selecto();\n     *\n     * window.addEventListener(\"mousedown\", e => {\n     *   selecto.triggerDragStart(e);\n     * });\n     */\n    public triggerDragStart(e: MouseEvent | TouchEvent) {\n        this.gesto.triggerDragStart(e);\n        return this;\n    }\n    /**\n     * Destroy elements, properties, and events.\n     */\n    public destroy() {\n        this.off();\n        this.keycon && this.keycon.destroy();\n        this.gesto.unset();\n        this.injectResult.destroy();\n        this.dragScroll.dragEnd();\n        removeEvent(document, \"selectstart\", this._onDocumentSelectStart);\n\n        if (!this.options.portalContainer) {\n            this.target.parentElement?.removeChild(this.target);\n        }\n\n\n        this.keycon = null;\n        this.gesto = null;\n        this.injectResult = null;\n        this.target = null;\n        this.container = null;\n        this.options = null;\n    }\n    public getElementPoints(target: ElementType) {\n        const getElementRect = this.getElementRect || getDefaultElementRect;\n        const info = getElementRect(target);\n        const points = [info.pos1, info.pos2, info.pos4, info.pos3];\n\n        if (getElementRect !== getDefaultElementRect) {\n            const rect = target.getBoundingClientRect();\n\n            return fitPoints(points, rect);\n        }\n        return points;\n    }\n    /**\n     * Get all elements set in `selectableTargets`.\n     */\n    public getSelectableElements() {\n        const container = this.container;\n        const selectableElements: ElementType[] = [];\n\n        this.options.selectableTargets.forEach((target) => {\n            if (isFunction(target)) {\n                const result = target();\n\n                if (result) {\n                    selectableElements.push(...[].slice.call(result));\n                }\n            } else if (isNode(target)) {\n                selectableElements.push(target);\n            } else if (isObject(target)) {\n                selectableElements.push(target.value || target.current);\n            } else {\n                const elements = [].slice.call(\n                    (getDocument(container)).querySelectorAll(target)\n                );\n\n                selectableElements.push(...elements);\n            }\n        });\n\n        return selectableElements;\n    }\n    /**\n     * If scroll occurs during dragging, you can manually call this method to check the position again.\n     */\n    public checkScroll() {\n        if (!this.gesto.isFlag()) {\n            return;\n        }\n        const scrollOptions = this.scrollOptions;\n        const innerScrollOptions = this.gesto.getEventData().innerScrollOptions;\n        const hasScrollOptions = innerScrollOptions || scrollOptions?.container;\n\n        // If it is a scrolling position, pass drag\n        if (hasScrollOptions) {\n            this.dragScroll.checkScroll({\n                inputEvent: this.gesto.getCurrentEvent(),\n                ...(innerScrollOptions || scrollOptions),\n            });\n        }\n    }\n    /**\n     * Find for selectableTargets again during drag event\n     * You can update selectable targets during an event.\n     */\n    public findSelectableTargets(data: IObject<any> = this.gesto.getEventData()) {\n        const selectableTargets = this.getSelectableElements();\n        const selectablePoints = selectableTargets.map(\n            (target) => this.getElementPoints(target),\n        );\n\n        data.selectableTargets = selectableTargets;\n        data.selectablePoints = selectablePoints;\n        data.selectableParentMap = null;\n\n        const options = this.options;\n        const hasIndexesMap = options.checkOverflow || options.innerScrollOptions;\n        const doc = getDocument(this.container);\n\n        if (hasIndexesMap) {\n            const parentMap = new Map<Element, InnerParentInfo>();\n\n            data.selectableInnerScrollParentMap = parentMap;\n            data.selectableInnerScrollPathsList = selectableTargets.map((target, index) => {\n                let parentElement = target.parentElement;\n\n                let parents: Element[] = [];\n                const paths: Element[] = [];\n\n                while (parentElement && parentElement !== doc.body) {\n                    let info: InnerParentInfo = parentMap.get(parentElement);\n\n                    if (!info) {\n                        const overflow = getComputedStyle(parentElement).overflow !== \"visible\";\n\n                        if (overflow) {\n                            const rect = getDefaultElementRect(parentElement);\n\n                            info = {\n                                parentElement,\n                                indexes: [],\n                                points: [rect.pos1, rect.pos2, rect.pos4, rect.pos3],\n                                paths: [...paths],\n                            };\n\n                            parents.push(parentElement);\n                            parents.forEach(prevParentElement => {\n                                parentMap.set(prevParentElement, info);\n                            });\n                            parents = [];\n                        }\n                    }\n                    if (info) {\n                        parentElement = info.parentElement;\n\n                        parentMap.get(parentElement).indexes.push(index);\n                        paths.push(parentElement);\n                    } else {\n                        parents.push(parentElement);\n                    }\n                    parentElement = parentElement.parentElement;\n                }\n\n                return paths;\n            });\n        }\n\n        if (!options.checkOverflow) {\n            data.selectableInners = selectableTargets.map(() => true);\n        }\n\n        this._refreshGroups(data);\n\n        return selectableTargets;\n    }\n    /**\n     * External click or mouse events can be applied to the selecto.\n     * @params - Extenal click or mouse event\n     * @params - Specify the clicked target directly.\n     */\n    public clickTarget(\n        e: MouseEvent | TouchEvent,\n        clickedTarget?: Element\n    ): this {\n        const { clientX, clientY } = getClient(e);\n        const dragEvent = {\n            data: {\n                selectFlag: false,\n            },\n            clientX,\n            clientY,\n            inputEvent: e,\n            isClick: true,\n            isTrusted: false,\n            stop: () => {\n                return false;\n            },\n        } as any;\n        if (this._onDragStart(dragEvent, clickedTarget)) {\n            this._onDragEnd(dragEvent);\n        }\n        return this;\n    }\n    private setKeyController() {\n        const { keyContainer, toggleContinueSelect, toggleContinueSelectWithoutDeselect } = this.options;\n\n        if (this.keycon) {\n            this.keycon.destroy();\n            this.keycon = null;\n        }\n        if (toggleContinueSelect || toggleContinueSelectWithoutDeselect) {\n            this.keycon = new KeyController(keyContainer || getWindow(this.container));\n            this.keycon\n                .keydown(this._onKeyDown)\n                .keyup(this._onKeyUp)\n                .on(\"blur\", this._onBlur);\n        }\n    }\n    private setClassName(nextClassName: string) {\n        this.options.className = nextClassName;\n        this.target.setAttribute(`class`, `${CLASS_NAME} ${nextClassName || \"\"}`);\n    }\n    private setKeyEvent() {\n        const { toggleContinueSelect, toggleContinueSelectWithoutDeselect } = this.options;\n        if ((!toggleContinueSelect && !toggleContinueSelectWithoutDeselect) || this.keycon) {\n            return;\n        }\n        this.setKeyController();\n    }\n    // with getter, setter property\n    private setKeyContainer(keyContainer: HTMLElement | Document | Window) {\n        const options = this.options;\n\n        diffValue(options.keyContainer, keyContainer, () => {\n            options.keyContainer = keyContainer;\n\n            this.setKeyController();\n        });\n    }\n    private getContinueSelect() {\n        const {\n            continueSelect,\n            toggleContinueSelect,\n        } = this.options;\n\n        if (!toggleContinueSelect || !this._keydownContinueSelect) {\n            return continueSelect;\n        }\n        return !continueSelect;\n    }\n    private getContinueSelectWithoutDeselect() {\n        const {\n            continueSelectWithoutDeselect,\n            toggleContinueSelectWithoutDeselect,\n        } = this.options;\n\n        if (!toggleContinueSelectWithoutDeselect || !this._keydownContinueSelectWithoutDeselection) {\n            return continueSelectWithoutDeselect;\n        }\n        return !continueSelectWithoutDeselect;\n    }\n    private setToggleContinueSelect(\n        toggleContinueSelect: string[][] | string[] | string\n    ) {\n        const options = this.options;\n\n        diffValue(options.toggleContinueSelect, toggleContinueSelect, () => {\n            options.toggleContinueSelect = toggleContinueSelect;\n\n            this.setKeyEvent();\n        });\n    }\n    private setToggleContinueSelectWithoutDeselect(\n        toggleContinueSelectWithoutDeselect: string[][] | string[] | string\n    ) {\n        const options = this.options;\n\n        diffValue(options.toggleContinueSelectWithoutDeselect, toggleContinueSelectWithoutDeselect, () => {\n            options.toggleContinueSelectWithoutDeselect = toggleContinueSelectWithoutDeselect;\n\n            this.setKeyEvent();\n        });\n    }\n    private setPreventDefault(value: boolean) {\n        this.gesto.options.preventDefault = value;\n    }\n    private setCheckInput(value: boolean) {\n        this.gesto.options.checkInput = value;\n    }\n    private initElement() {\n        const {\n            dragContainer,\n            checkInput,\n            preventDefault,\n            preventClickEventOnDragStart,\n            preventClickEventOnDrag,\n            preventClickEventByCondition,\n            preventRightClick = true,\n            className,\n        } = this.options;\n        const container = this.container;\n\n        this.target = createElement(\n            (<div className={`${CLASS_NAME} ${className || \"\"}`}></div>) as any,\n            this.target,\n            container,\n        );\n\n\n        const target = this.target;\n\n        this.dragContainer =\n            typeof dragContainer === \"string\"\n                ? [].slice.call(getDocument(container).querySelectorAll(dragContainer))\n                : dragContainer || (this.target.parentNode as any);\n        this.gesto = new Gesto(this.dragContainer, {\n            checkWindowBlur: true,\n            container: getWindow(container),\n            checkInput,\n            preventDefault,\n            preventClickEventOnDragStart,\n            preventClickEventOnDrag,\n            preventClickEventByCondition,\n            preventRightClick,\n        }).on({\n            dragStart: this._onDragStart,\n            drag: this._onDrag,\n            dragEnd: this._onDragEnd,\n        });\n        addEvent(document, \"selectstart\", this._onDocumentSelectStart);\n\n        this.injectResult = injector.inject(target, {\n            nonce: this.options.cspNonce,\n        });\n    }\n    private hitTest(\n        selectRect: Rect,\n        data: any,\n        isDrag: boolean,\n        gestoEvent: any,\n    ) {\n        const { hitRate, selectByClick } = this.options;\n        const { left, top, right, bottom } = selectRect;\n        const innerGroups: Record<string | number, Record<string | number, number[]>> = data.innerGroups;\n        const innerWidth = data.innerWidth;\n        const innerHeight = data.innerHeight;\n        const clientX = gestoEvent?.clientX;\n        const clientY = gestoEvent?.clientY;\n        const ignoreClick = data.ignoreClick;\n        const rectPoints = [\n            [left, top],\n            [right, top],\n            [right, bottom],\n            [left, bottom],\n        ];\n        const isHit = (points: number[][], el: Element) => {\n            const hitRateValue =\n                typeof hitRate === \"function\"\n                    ? splitUnit(`${hitRate(el)}`)\n                    : splitUnit(`${hitRate}`);\n\n            const inArea = ignoreClick\n                ? false\n                : isInside([clientX, clientY], points);\n\n            if (!isDrag && selectByClick && inArea) {\n                return true;\n            }\n            const overlapPoints = getOverlapPoints(rectPoints, points);\n\n            if (!overlapPoints.length) {\n                return false;\n            }\n            let overlapSize = getAreaSize(overlapPoints);\n\n            // Line\n            let targetSize = 0;\n\n            if (overlapSize === 0 && getAreaSize(points) === 0) {\n                targetSize = getLineSize(points);\n                overlapSize = getLineSize(overlapPoints);\n            } else {\n                targetSize = getAreaSize(points);\n            }\n\n\n            if (hitRateValue.unit === \"px\") {\n                return overlapSize >= hitRateValue.value;\n            } else {\n                const rate = between(\n                    Math.round((overlapSize / targetSize) * 100),\n                    0,\n                    100\n                );\n\n                return rate >= Math.min(100, hitRateValue.value);\n            }\n        };\n        const selectableTargets: ElementType[] = data.selectableTargets;\n        const selectablePoints: number[][][] = data.selectablePoints;\n        const selectableInners: boolean[] = data.selectableInners;\n\n        if (!innerGroups) {\n            return selectableTargets.filter((_, i) => {\n                if (!selectableInners[i]) {\n                    return false;\n                }\n                return isHit(selectablePoints[i], selectableTargets[i]);\n            });\n        }\n        const selectedTargets: ElementType[] = [];\n        const minX = Math.floor(left / innerWidth);\n        const maxX = Math.floor(right / innerWidth);\n        const minY = Math.floor(top / innerHeight);\n        const maxY = Math.floor(bottom / innerHeight);\n\n        for (let x = minX; x <= maxX; ++x) {\n            const yGroups = innerGroups[x];\n\n            if (!yGroups) {\n                continue;\n            }\n            for (let y = minY; y <= maxY; ++y) {\n                const group = yGroups[y];\n\n                if (!group) {\n                    continue;\n                }\n                group.forEach(index => {\n                    const points = selectablePoints[index];\n                    const inner = selectableInners[index];\n                    const target = selectableTargets[index];\n\n                    if (inner && isHit(points, target)) {\n                        selectedTargets.push(target);\n                    }\n                });\n            }\n        }\n        return filterDuplicated(selectedTargets);\n    }\n    private initDragScroll() {\n        this.dragScroll\n            .on(\"scrollDrag\", ({ next }) => {\n                next(this.gesto.getCurrentEvent());\n            })\n            .on(\"scroll\", ({ container, direction }) => {\n                const innerScrollOptions = this.gesto.getEventData().innerScrollOptions;\n\n                if (innerScrollOptions) {\n                    this.emit(\"innerScroll\", {\n                        container,\n                        direction,\n                    });\n                } else {\n                    this.emit(\"scroll\", {\n                        container,\n                        direction,\n                    });\n                }\n            })\n            .on(\"move\", ({ offsetX, offsetY, inputEvent }) => {\n                const gesto = this.gesto;\n\n                if (!gesto || !gesto.isFlag()) {\n                    return;\n                }\n\n                const data = this.gesto.getEventData();\n                const boundArea = data.boundArea;\n\n                data.startX -= offsetX;\n                data.startY -= offsetY;\n\n                const innerScrollOptions = this.gesto.getEventData().innerScrollOptions;\n                const container = innerScrollOptions?.container;\n                let isMoveInnerScroll = false;\n\n                if (container) {\n                    const parentMap: Map<Element, InnerParentInfo> = data.selectableInnerScrollParentMap;\n                    const parentInfo = parentMap.get(container);\n\n                    if (parentInfo) {\n                        parentInfo.paths.forEach(scrollContainer => {\n                            const containerInfo = parentMap.get(scrollContainer);\n\n                            containerInfo.points.forEach(pos => {\n                                pos[0] -= offsetX;\n                                pos[1] -= offsetY;\n                            });\n                        });\n                        parentInfo.indexes.forEach(index => {\n                            data.selectablePoints[index].forEach((pos) => {\n                                pos[0] -= offsetX;\n                                pos[1] -= offsetY;\n                            });\n                        });\n                        isMoveInnerScroll = true;\n                    }\n                }\n                if (!isMoveInnerScroll) {\n                    data.selectablePoints.forEach((points: number[][]) => {\n                        points.forEach((pos) => {\n                            pos[0] -= offsetX;\n                            pos[1] -= offsetY;\n                        });\n                    });\n                }\n                this._refreshGroups(data);\n\n                boundArea.left -= offsetX;\n                boundArea.right -= offsetX;\n                boundArea.top -= offsetY;\n                boundArea.bottom -= offsetY;\n\n                this.gesto.scrollBy(\n                    offsetX,\n                    offsetY,\n                    inputEvent.inputEvent,\n                    // false\n                );\n                this._checkSelected(this.gesto.getCurrentEvent());\n            });\n    }\n    private _select(\n        selectedTargets: ElementType[],\n        rect: Rect,\n        e: OnDragEvent,\n        isStart?: boolean,\n        isDragStartEnd = false,\n    ) {\n        const inputEvent = e.inputEvent;\n        const data = e.data;\n        const result = this.setSelectedTargets(selectedTargets);\n        const { added, removed, prevList, list } = diff(\n            data.startSelectedTargets,\n            selectedTargets,\n        );\n\n        const startResult = {\n            startSelected: prevList,\n            startAdded: added.map(i => list[i]),\n            startRemoved: removed.map(i => prevList[i]),\n        };\n\n\n        if (isStart) {\n            /**\n             * When the select(drag) starts, the selectStart event is called.\n             * @memberof Selecto\n             * @event selectStart\n             * @param {Selecto.OnSelect} - Parameters for the selectStart event\n             * @example\n             * import Selecto from \"selecto\";\n             *\n             * const selecto = new Selecto({\n             *   container: document.body,\n             *   selectByClick: true,\n             *   selectFromInside: false,\n             * });\n             *\n             * selecto.on(\"selectStart\", e => {\n             *   e.added.forEach(el => {\n             *     el.classList.add(\"selected\");\n             *   });\n             *   e.removed.forEach(el => {\n             *     el.classList.remove(\"selected\");\n             *   });\n             * }).on(\"selectEnd\", e => {\n             *   e.afterAdded.forEach(el => {\n             *     el.classList.add(\"selected\");\n             *   });\n             *   e.afterRemoved.forEach(el => {\n             *     el.classList.remove(\"selected\");\n             *   });\n             * });\n             */\n            this.emit(\"selectStart\", {\n                ...result,\n                ...startResult,\n                rect,\n                inputEvent,\n                data: data.data,\n                isTrusted: e.isTrusted,\n                isDragStartEnd,\n            });\n        }\n        if (result.added.length || result.removed.length) {\n            /**\n             * When the select in real time, the select event is called.\n             * @memberof Selecto\n             * @event select\n             * @param {Selecto.OnSelect} - Parameters for the select event\n             * @example\n             * import Selecto from \"selecto\";\n             *\n             * const selecto = new Selecto({\n             *   container: document.body,\n             *   selectByClick: true,\n             *   selectFromInside: false,\n             * });\n             *\n             * selecto.on(\"select\", e => {\n             *   e.added.forEach(el => {\n             *     el.classList.add(\"selected\");\n             *   });\n             *   e.removed.forEach(el => {\n             *     el.classList.remove(\"selected\");\n             *   });\n             * });\n             */\n            this.emit(\"select\", {\n                ...result,\n                ...startResult,\n                rect,\n                inputEvent,\n                data: data.data,\n                isTrusted: e.isTrusted,\n                isDragStartEnd,\n            });\n        }\n    }\n    private _selectEnd(\n        startSelectedTargets: ElementType[],\n        startPassedTargets: ElementType[],\n        rect: Rect,\n        e: OnDragEvent,\n        isDragStartEnd: boolean = false,\n    ) {\n        const { inputEvent, isDouble, data } = e;\n        const type = inputEvent && inputEvent.type;\n        const isDragStart = type === \"mousedown\" || type === \"touchstart\";\n\n        const { added, removed, prevList, list } = diff(\n            startSelectedTargets,\n            this.selectedTargets\n        );\n        const {\n            added: afterAdded,\n            removed: afterRemoved,\n            prevList: afterPrevList,\n            list: afterList,\n        } = diff(startPassedTargets, this.selectedTargets);\n\n        /**\n         * When the select(dragEnd or click) ends, the selectEnd event is called.\n         * @memberof Selecto\n         * @event selectEnd\n         * @param {Selecto.OnSelectEnd} - Parameters for the selectEnd event\n         * @example\n         * import Selecto from \"selecto\";\n         *\n         * const selecto = new Selecto({\n         *   container: document.body,\n         *   selectByClick: true,\n         *   selectFromInside: false,\n         * });\n         *\n         * selecto.on(\"selectStart\", e => {\n         *   e.added.forEach(el => {\n         *     el.classList.add(\"selected\");\n         *   });\n         *   e.removed.forEach(el => {\n         *     el.classList.remove(\"selected\");\n         *   });\n         * }).on(\"selectEnd\", e => {\n         *   e.afterAdded.forEach(el => {\n         *     el.classList.add(\"selected\");\n         *   });\n         *   e.afterRemoved.forEach(el => {\n         *     el.classList.remove(\"selected\");\n         *   });\n         * });\n         */\n        this.emit(\"selectEnd\", {\n            startSelected: startSelectedTargets,\n            beforeSelected: startPassedTargets,\n            selected: this.selectedTargets,\n            added: added.map((index) => list[index]),\n            removed: removed.map((index) => prevList[index]),\n            afterAdded: afterAdded.map((index) => afterList[index]),\n            afterRemoved: afterRemoved.map((index) => afterPrevList[index]),\n            isDragStart: isDragStart && isDragStartEnd,\n            isDragStartEnd: isDragStart && isDragStartEnd,\n            isClick: !!e.isClick,\n            isDouble: !!isDouble,\n            rect,\n            inputEvent,\n            data: data.data,\n            isTrusted: e.isTrusted,\n        });\n    }\n    private _onDragStart = (e: OnDragStart<Gesto>, clickedTarget?: Element) => {\n        const { data, clientX, clientY, inputEvent } = e;\n        const {\n            selectFromInside,\n            selectByClick,\n            rootContainer,\n            boundContainer,\n            preventDragFromInside = true,\n            clickBySelectEnd,\n            dragCondition,\n        } = this.options;\n\n        if (dragCondition && !dragCondition(e)) {\n            e.stop();\n            return;\n        }\n        data.data = {};\n        const win = getWindow(this.container);\n        data.innerWidth = win.innerWidth;\n        data.innerHeight = win.innerHeight;\n        this.findSelectableTargets(data);\n        data.startSelectedTargets = this.selectedTargets;\n        data.scaleMatrix = createMatrix();\n        data.containerX = 0;\n        data.containerY = 0;\n\n\n        const container = this.container;\n        let boundArea = {\n            left: -Infinity,\n            top: -Infinity,\n            right: Infinity,\n            bottom: Infinity,\n        };\n        if (rootContainer) {\n            const containerRect = this.container.getBoundingClientRect();\n\n            data.containerX = containerRect.left;\n            data.containerY = containerRect.top;\n            data.scaleMatrix = getDistElementMatrix(this.container, rootContainer);\n        }\n\n        if (boundContainer) {\n            const boundInfo: Required<BoundContainer> =\n                isObject(boundContainer) && \"element\" in boundContainer\n                    ? {\n                        left: true,\n                        top: true,\n                        bottom: true,\n                        right: true,\n                        ...boundContainer,\n                    }\n                    : {\n                        element: boundContainer,\n                        left: true,\n                        top: true,\n                        bottom: true,\n                        right: true,\n                    };\n            const boundElement = boundInfo.element;\n            let rectElement: HTMLElement;\n\n            if (boundElement) {\n                if (isString(boundElement)) {\n                    rectElement = getDocument(container).querySelector(boundElement);\n                } else if (boundElement === true) {\n                    rectElement = this.container;\n                } else {\n                    rectElement = boundElement;\n                }\n                const rect = rectElement.getBoundingClientRect();\n\n                if (boundInfo.left) {\n                    boundArea.left = rect.left;\n                }\n                if (boundInfo.top) {\n                    boundArea.top = rect.top;\n                }\n                if (boundInfo.right) {\n                    boundArea.right = rect.right;\n                }\n                if (boundInfo.bottom) {\n                    boundArea.bottom = rect.bottom;\n                }\n            }\n        }\n\n        data.boundArea = boundArea;\n\n        const hitRect = {\n            left: clientX,\n            top: clientY,\n            right: clientX,\n            bottom: clientY,\n            width: 0,\n            height: 0,\n        };\n        let firstPassedTargets: ElementType[] = [];\n\n        // allow click on select\n        const allowClickBySelectEnd = selectByClick && !clickBySelectEnd;\n        let hasInsideTargets = false;\n\n        if (!selectFromInside || allowClickBySelectEnd) {\n            const pointTarget = this._findElement(\n                clickedTarget || inputEvent.target, // elementFromPoint(clientX, clientY),\n                data.selectableTargets,\n            );\n\n            hasInsideTargets = !!pointTarget;\n            if (allowClickBySelectEnd) {\n                firstPassedTargets = pointTarget ? [pointTarget] : [];\n            }\n        }\n        const isPreventSelect = !selectFromInside && hasInsideTargets;\n\n        // prevent drag from inside when selectByClick is false\n        if (isPreventSelect && !selectByClick) {\n            e.stop();\n            return false;\n        }\n\n        const type = inputEvent.type;\n        const isTrusted = type === \"mousedown\" || type === \"touchstart\";\n        /**\n         * When the drag starts (triggers on mousedown or touchstart), the dragStart event is called.\n         * Call the stop () function if you have a specific element or don't want to raise a select\n         * @memberof Selecto\n         * @event dragStart\n         * @param {OnDragStart} - Parameters for the dragStart event\n         * @example\n         * import Selecto from \"selecto\";\n         *\n         * const selecto = new Selecto({\n         *   container: document.body,\n         *   selectByClick: true,\n         *   selectFromInside: false,\n         * });\n         *\n         * selecto.on(\"dragStart\", e => {\n         *   if (e.inputEvent.target.tagName === \"SPAN\") {\n         *     e.stop();\n         *   }\n         * }).on(\"select\", e => {\n         *   e.added.forEach(el => {\n         *     el.classList.add(\"selected\");\n         *   });\n         *   e.removed.forEach(el => {\n         *     el.classList.remove(\"selected\");\n         *   });\n         * });\n         */\n        const result =\n            !(e).isClick && isTrusted\n                ? this.emit(\"dragStart\", { ...e, data: data.data })\n                : true;\n\n        if (!result) {\n            e.stop();\n            return false;\n        }\n\n        if (this.continueSelect) {\n            firstPassedTargets = passTargets(\n                this.selectedTargets,\n                firstPassedTargets,\n                this.continueSelectWithoutDeselect,\n            );\n            data.startPassedTargets = this.selectedTargets;\n        } else {\n            data.startPassedTargets = [];\n        }\n\n        this._select(\n            firstPassedTargets,\n            hitRect,\n            e,\n            true,\n            isPreventSelect && selectByClick && !clickBySelectEnd && preventDragFromInside,\n        );\n        data.startX = clientX;\n        data.startY = clientY;\n        data.selectFlag = false;\n        data.preventDragFromInside = false;\n\n        if (inputEvent.target) {\n            const offsetPos = calculateMatrixDist(data.scaleMatrix, [\n                clientX - data.containerX,\n                clientY - data.containerY,\n            ]);\n            this.target.style.cssText += `position: ${rootContainer ? \"absolute\" : \"fixed\"};`\n                + `left:0px;top:0px;`\n                + `transform: translate(${offsetPos[0]}px, ${offsetPos[1]}px)`;\n        }\n\n        if (isPreventSelect && selectByClick && !clickBySelectEnd) {\n            inputEvent.preventDefault();\n\n            // prevent drag from inside when selectByClick is true and force call `selectEnd`\n            if (preventDragFromInside) {\n                this._selectEnd(\n                    data.startSelectedTargets,\n                    data.startPassedTargets,\n                    hitRect,\n                    e,\n                    true,\n                );\n                data.preventDragFromInside = true;\n            }\n        } else {\n            data.selectFlag = true;\n            // why?\n            // if (type === \"touchstart\") {\n            //     inputEvent.preventDefault();\n            // }\n            const { scrollOptions, innerScrollOptions } = this.options;\n\n            let isInnerScroll = false\n\n            if (innerScrollOptions) {\n                const inputEvent = e.inputEvent;\n                const target = inputEvent.target;\n\n                let innerScrollElement: HTMLElement | null = null;\n                let parentElement = target;\n\n                while (parentElement && parentElement !== getDocument(container).body) {\n\n                    const overflow = getComputedStyle(parentElement).overflow !== \"visible\";\n\n                    if (overflow) {\n                        innerScrollElement = parentElement;\n                        break;\n                    }\n                    parentElement = parentElement.parentElement;\n                }\n                if (innerScrollElement) {\n                    data.innerScrollOptions = {\n                        container: innerScrollElement,\n                        checkScrollEvent: true,\n                        ...(innerScrollOptions === true ? {} : innerScrollOptions),\n                    };\n                    this.dragScroll.dragStart(e, data.innerScrollOptions);\n\n                    isInnerScroll = true;\n                }\n            }\n            if (!isInnerScroll && scrollOptions && scrollOptions.container) {\n                this.dragScroll.dragStart(e, scrollOptions);\n            }\n\n            if (isPreventSelect && selectByClick && clickBySelectEnd) {\n                data.selectFlag = false;\n                e.preventDrag();\n            }\n        }\n        return true;\n    };\n    private _checkSelected(e: any, rect = getRect(e, this.options.ratio)) {\n        const { data } = e;\n        const { top, left, width, height } = rect;\n        const selectFlag = data.selectFlag;\n        const {\n            containerX,\n            containerY,\n            scaleMatrix,\n        } = data;\n        const offsetPos = calculateMatrixDist(scaleMatrix, [\n            left - containerX,\n            top - containerY,\n        ]);\n        const offsetSize = calculateMatrixDist(scaleMatrix, [\n            width,\n            height,\n        ]);\n        let selectedTargets: ElementType[] = [];\n        if (selectFlag) {\n            this.target.style.cssText +=\n                `display: block;` +\n                `left:0px;top:0px;` +\n                `transform: translate(${offsetPos[0]}px, ${offsetPos[1]}px);` +\n                `width:${offsetSize[0]}px;height:${offsetSize[1]}px;`;\n\n            const passedTargets = this.hitTest(\n                rect,\n                data,\n                true,\n                e,\n            );\n            selectedTargets = passTargets(\n                data.startPassedTargets,\n                passedTargets,\n                this.continueSelect && this.continueSelectWithoutDeselect,\n            );\n        }\n        /**\n         * When the drag, the drag event is called.\n         * Call the stop () function if you have a specific element or don't want to raise a select\n         * @memberof Selecto\n         * @event drag\n         * @param {OnDrag} - Parameters for the drag event\n         * @example\n         * import Selecto from \"selecto\";\n         *\n         * const selecto = new Selecto({\n         *   container: document.body,\n         *   selectByClick: true,\n         *   selectFromInside: false,\n         * });\n         *\n         * selecto.on(\"drag\", e => {\n         *   e.stop();\n         * }).on(\"select\", e => {\n         *   e.added.forEach(el => {\n         *     el.classList.add(\"selected\");\n         *   });\n         *   e.removed.forEach(el => {\n         *     el.classList.remove(\"selected\");\n         *   });\n         * });\n         */\n        const result = this.emit(\"drag\", {\n            ...e,\n            data: data.data,\n            isSelect: selectFlag,\n            rect,\n        });\n        if (result === false) {\n            this.target.style.cssText += \"display: none;\";\n            e.stop();\n            return;\n        }\n\n        if (selectFlag) {\n            this._select(selectedTargets, rect, e);\n        }\n    }\n    private _onDrag = (e: OnDrag) => {\n        if (e.data.selectFlag) {\n            const scrollOptions = this.scrollOptions;\n            const innerScrollOptions = e.data.innerScrollOptions;\n            const hasScrollOptions = innerScrollOptions || scrollOptions?.container;\n\n            // If it is a scrolling position, pass drag\n            if (hasScrollOptions && !e.isScroll && this.dragScroll.drag(e, innerScrollOptions || scrollOptions)) {\n                return;\n            }\n        }\n        this._checkSelected(e);\n    };\n    private _onDragEnd = (e: OnDragEvent) => {\n        const { data, inputEvent } = e;\n        const rect = getRect(e, this.options.ratio);\n        const selectFlag = data.selectFlag;\n        const container = this.container;\n\n        /**\n         * When the drag ends (triggers on mouseup or touchend after drag), the dragEnd event is called.\n         * @memberof Selecto\n         * @event dragEnd\n         * @param {OnDragEnd} - Parameters for the dragEnd event\n         */\n        if (inputEvent) {\n            this.emit(\"dragEnd\", {\n                isDouble: !!e.isDouble,\n                isClick: !!e.isClick,\n                isDrag: false,\n                isSelect: selectFlag,\n                ...e,\n                data: data.data,\n                rect,\n            });\n        }\n        this.target.style.cssText += \"display: none;\";\n\n        if (selectFlag) {\n            data.selectFlag = false;\n            this.dragScroll.dragEnd();\n        } else if (this.selectByClick && this.clickBySelectEnd) {\n            // only clickBySelectEnd\n            const pointTarget = this._findElement(\n                inputEvent?.target || elementFromPoint(container, e.clientX, e.clientY),\n                data.selectableTargets,\n            );\n            this._select(pointTarget ? [pointTarget] : [], rect, e);\n        }\n        if (!data.preventDragFromInside) {\n            this._selectEnd(\n                data.startSelectedTargets,\n                data.startPassedTargets,\n                rect,\n                e\n            );\n        }\n    };\n    private _sameCombiKey(e: any, keys: string | string[] | string[][], isKeyup?: boolean) {\n        if (!keys) {\n            return false;\n        }\n        const combi = getCombi(e.inputEvent, e.key);\n        const nextKeys = [].concat(keys);\n        const toggleKeys = isArray(nextKeys[0]) ? nextKeys : [nextKeys];\n\n        if (isKeyup) {\n            const singleKey = e.key;\n\n            return toggleKeys.some((keys) =>\n                keys.some((key: string) => key === singleKey)\n            );\n        }\n        return toggleKeys.some((keys) =>\n            keys.every((key: string) => combi.indexOf(key) > -1)\n        );\n    }\n    private _onKeyDown = (e: KeyControllerEvent) => {\n        const options = this.options;\n        let isKeyDown = false;\n\n        if (!this._keydownContinueSelect) {\n            const result = this._sameCombiKey(e, options.toggleContinueSelect);\n\n            this._keydownContinueSelect = result;\n            isKeyDown ||= result;\n        }\n        if (!this._keydownContinueSelectWithoutDeselection) {\n            const result = this._sameCombiKey(e, options.toggleContinueSelectWithoutDeselect);\n\n            this._keydownContinueSelectWithoutDeselection = result;\n            isKeyDown ||= result;\n        }\n        if (!isKeyDown) {\n            return;\n        }\n        /**\n         * When you keydown the key you specified in toggleContinueSelect, the keydown event is called.\n         * @memberof Selecto\n         * @event keydown\n         * @example\n         * import Selecto from \"selecto\";\n         *\n         * const selecto = new Selecto({\n         *   container: document.body,\n         *   toggleContinueSelect: \"shift\";\n         *   keyContainer: window,\n         * });\n         *\n         * selecto.on(\"keydown\", () => {\n         *   document.querySelector(\".button\").classList.add(\"selected\");\n         * }).on(\"keyup\", () => {\n         *   document.querySelector(\".button\").classList.remove(\"selected\");\n         * }).on(\"select\", e => {\n         *   e.added.forEach(el => {\n         *     el.classList.add(\"selected\");\n         *   });\n         *   e.removed.forEach(el => {\n         *     el.classList.remove(\"selected\");\n         *   });\n         * });\n         */\n        this.emit(\"keydown\", {\n            keydownContinueSelect: this._keydownContinueSelect,\n            keydownContinueSelectWithoutDeselection: this._keydownContinueSelectWithoutDeselection,\n        });\n    };\n    private _onKeyUp = (e: KeyControllerEvent) => {\n        const options = this.options;\n        let isKeyUp = false;\n\n        if (this._keydownContinueSelect) {\n            const result = this._sameCombiKey(e, options.toggleContinueSelect, true);\n            this._keydownContinueSelect = !result;\n\n            isKeyUp ||= result;\n        }\n        if (this._keydownContinueSelectWithoutDeselection) {\n            const result = this._sameCombiKey(e, options.toggleContinueSelectWithoutDeselect, true);\n            this._keydownContinueSelectWithoutDeselection = !result;\n\n            isKeyUp ||= result;\n        }\n        if (!isKeyUp) {\n            return;\n        }\n\n        /**\n         * When you keyup the key you specified in toggleContinueSelect, the keyup event is called.\n         * @memberof Selecto\n         * @event keyup\n         * @example\n         * import Selecto from \"selecto\";\n         *\n         * const selecto = new Selecto({\n         *   container: document.body,\n         *   toggleContinueSelect: \"shift\";\n         *   keyContainer: window,\n         * });\n         *\n         * selecto.on(\"keydown\", () => {\n         *   document.querySelector(\".button\").classList.add(\"selected\");\n         * }).on(\"keyup\", () => {\n         *   document.querySelector(\".button\").classList.remove(\"selected\");\n         * }).on(\"select\", e => {\n         *   e.added.forEach(el => {\n         *     el.classList.add(\"selected\");\n         *   });\n         *   e.removed.forEach(el => {\n         *     el.classList.remove(\"selected\");\n         *   });\n         * });\n         */\n        this.emit(\"keyup\", {\n            keydownContinueSelect: this._keydownContinueSelect,\n            keydownContinueSelectWithoutDeselection: this._keydownContinueSelectWithoutDeselection,\n        });\n    };\n    private _onBlur = () => {\n        if (this._keydownContinueSelect || this._keydownContinueSelectWithoutDeselection) {\n            this._keydownContinueSelect = false;\n            this._keydownContinueSelectWithoutDeselection = false;\n            this.emit(\"keyup\", {\n                keydownContinueSelect: this._keydownContinueSelect,\n                keydownContinueSelectWithoutDeselection: this._keydownContinueSelectWithoutDeselection,\n            });\n        }\n    };\n    private _onDocumentSelectStart = (e: any) => {\n        const doc = getDocument(this.container);\n\n        if (!this.gesto.isFlag()) {\n            return;\n        }\n        let dragContainer = this.dragContainer;\n\n        if (dragContainer === getWindow(this.container)) {\n            dragContainer = doc.documentElement;\n        }\n        const containers = isNode(dragContainer)\n            ? [dragContainer]\n            : ([].slice.call(dragContainer) as Element[]);\n        const target = e.target;\n\n        containers.some((container) => {\n            if (container === target || container.contains(target)) {\n                e.preventDefault();\n                return true;\n            }\n        });\n    };\n    private _findElement(clickedTarget: ElementType, selectableTargets: Element[]) {\n        let pointTarget = clickedTarget;\n\n        while (pointTarget) {\n            if (selectableTargets.indexOf(pointTarget) > -1) {\n                break;\n            }\n            pointTarget = pointTarget.parentElement;\n        }\n        return pointTarget;\n    }\n    private _refreshGroups(data: IObject<any>) {\n        const innerWidth = data.innerWidth;\n        const innerHeight = data.innerHeight;\n        const selectablePoints: number[][][] = data.selectablePoints;\n\n        if (this.options.checkOverflow) {\n            const innerScrollContainer = this.gesto.getEventData().innerScrollOptions?.container;\n            const parentMap: Map<Element, InnerParentInfo> = data.selectableInnerScrollParentMap;\n            const innerScrollPathsList: Element[][] = data.selectableInnerScrollPathsList;\n\n            data.selectableInners = innerScrollPathsList.map((innerScrollPaths, i) => {\n                let isAlwaysTrue = false;\n                return innerScrollPaths.every(target => {\n                    if (isAlwaysTrue) {\n                        return true;\n                    }\n                    if (target === innerScrollContainer) {\n                        isAlwaysTrue = true;\n                        return true;\n                    }\n\n                    const rect = parentMap.get(target);\n\n                    if (rect) {\n                        const points1 = selectablePoints[i];\n                        const points2 = rect.points;\n                        const overlapPoints = getOverlapPoints(points1, points2);\n\n                        if (!overlapPoints.length) {\n                            return false;\n                        }\n                    }\n                    return true;\n                });\n            });\n        }\n        if (!innerWidth || !innerHeight) {\n            data.innerGroups = null;\n        } else {\n            const selectablePoints: number[][][] = data.selectablePoints;\n\n            const groups: Record<string | number, Record<string | number, number[]>> = {};\n\n            selectablePoints.forEach((points, i) => {\n                let minX = Infinity;\n                let maxX = -Infinity;\n                let minY = Infinity;\n                let maxY = -Infinity;\n\n                points.forEach(pos => {\n                    const x = Math.floor(pos[0] / innerWidth);\n                    const y = Math.floor(pos[1] / innerHeight);\n\n                    minX = Math.min(x, minX);\n                    maxX = Math.max(x, maxX);\n                    minY = Math.min(y, minY);\n                    maxY = Math.max(y, maxY);\n                });\n\n                for (let x = minX; x <= maxX; ++x) {\n                    for (let y = minY; y <= maxY; ++y) {\n                        groups[x] = groups[x] || {};\n                        groups[x][y] = groups[x][y] || [];\n\n                        groups[x][y].push(i);\n                    }\n                }\n            });\n\n            data.innerGroups = groups;\n        }\n    }\n}\n\ninterface Selecto extends SelectoProperties { }\n\nexport default Selecto;\n", "import SelectoManager from \"./SelectoManager\";\n\nclass Selecto extends SelectoManager {\n\n}\nexport default Selecto;\n", "import { EVENTS } from \"selecto\";\nimport { camelize } from \"@daybrush/utils\";\n\nexport const REACT_EVENTS =  EVENTS.map(name => camelize(`on ${name}`));\n", "import * as React from \"react\";\nimport VanillaSelecto, {\n    CLASS_NAME,\n    OPTIONS,\n    SelectoOptions,\n    PROPERTIES,\n    SelectoProperties,\n    EVENTS,\n    SelectoMethods,\n    METHODS,\n} from \"selecto\";\nimport { ref, MethodInterface, withMethods } from \"framework-utils\";\nimport { SelectoProps } from \"./types\";\nimport { REACT_EVENTS } from \"./consts\";\n\nexport default class Selecto extends React.PureComponent<Partial<SelectoProps>> {\n    @withMethods(METHODS as any)\n    private selecto!: VanillaSelecto;\n    private selectionElement!: HTMLElement;\n    public render() {\n        return <div className={CLASS_NAME} ref={ref(this, \"selectionElement\")}></div>;\n    }\n    public componentDidMount() {\n        const props = this.props;\n        const options: Partial<SelectoOptions> = {};\n\n        OPTIONS.forEach(name => {\n            if (name in props) {\n                (options as any)[name] = props[name];\n            }\n        });\n        this.selecto = new VanillaSelecto({\n            ...options,\n            portalContainer: this.selectionElement,\n        });\n\n        EVENTS.forEach((name, i) => {\n            this.selecto.on(name, (e: any) => {\n                const selfProps = this.props as any;\n                const result = selfProps[REACT_EVENTS[i]] && selfProps[REACT_EVENTS[i]](e);\n\n                if (result === false) {\n                    e.stop();\n                }\n            });\n        });\n    }\n    public componentDidUpdate(prevProps: Partial<SelectoProperties>) {\n        const props = this.props;\n        const selecto = this.selecto;\n\n        PROPERTIES.forEach(name => {\n            if (prevProps[name] !== props[name]) {\n                (selecto as any)[name] = props[name];\n            }\n        });\n    }\n    public componentWillUnmount() {\n        this.selecto.destroy();\n    }\n}\nexport default interface Selecto extends MethodInterface<SelectoMethods, VanillaSelecto, Selecto> {}\n"],
  "mappings": "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",
  "names": ["codeData", "keysSort", "shift", "ctrl", "alt", "meta", "getKey", "keyCode", "keyName", "key", "names", "toLowerCase", "name", "replace", "getCombi", "e", "keys", "getModifierCombi", "indexOf", "push", "filter", "Boolean", "shiftKey", "ctrlKey", "altKey", "metaKey", "getArrangeCombi", "arrangeKeys", "slice", "sort", "prev", "next", "prevScore", "nextScore", "globalKeyController", "__extends", "KeyController", "container", "_super", "_this", "triggerEvent", "clear", "trigger", "addEvent", "blur", "keydownEvent", "keyupEvent", "Object", "global", "off", "removeEvent", "comb", "callback", "type", "isArray", "on", "join", "isString", "isToggle", "param", "inputEvent", "combi", "length", "EventEmitter", "getClient", "e", "touch", "touches", "changedTouches", "clientX", "clientY", "filterDuplicated", "arr", "Map", "filter", "value", "index", "indexOf", "map", "has", "set", "elementFromPoint", "baseNode", "doc", "getDocument", "createElement", "jsx", "prevTarget", "container", "tag", "children", "attributes", "className", "style", "el", "name", "setAttribute", "elChildren", "forEach", "child", "i", "split", "hasClass", "addClass", "elStyle", "appendChild", "h", "attrs", "_i", "_a", "_b", "_c", "diffValue", "prev", "cur", "func", "getRect", "ratio", "boundArea", "data", "distX", "distY", "_d", "startX", "startY", "nextHeight", "Math", "sqrt", "nextWidth", "width", "abs", "height", "maxWidth", "left", "right", "maxHeight", "top", "bottom", "calculateBoundSize", "tx", "min", "ty", "getDefaultElementRect", "rect", "getBoundingClientRect", "pos1", "pos2", "pos3", "pos4", "passTargets", "beforeTargets", "afterTargets", "continueSelectWithoutDeselect", "diff", "list", "prevList", "added", "removed", "maintained", "nextIndex", "getLineSize", "points", "size", "length", "max", "getDist", "injector", "styled", "CLASS_NAME", "PROPERTIES", "OPTIONS", "__spreadArray", "OPTION_TYPES", "String", "boundContainer", "portalContainer", "dragContainer", "selectableTargets", "Array", "selectByClick", "Boolean", "selectFromInside", "continueSelect", "toggleContinueSelect", "toggleContinueSelectWithoutDeselect", "keyContainer", "hitRate", "Number", "scrollOptions", "Object", "checkInput", "preventDefault", "cspNonce", "getElementRect", "Function", "preventDragFromInside", "rootContainer", "dragCondition", "clickBySelectEnd", "preventClickEventOnDragStart", "preventClickEventOnDrag", "checkOverflow", "innerScrollOptions", "EVENTS", "METHODS", "__extends", "Selecto", "options", "_super", "_this", "DragScroll", "clickedTarget", "inputEvent", "stop", "win", "getWindow", "innerWidth", "innerHeight", "findSelectableTargets", "startSelectedTargets", "selectedTargets", "scaleMatrix", "createMatrix", "containerX", "containerY", "Infinity", "containerRect", "getDistElementMatrix", "boundInfo", "isObject", "element", "boundElement", "rectElement", "isString", "querySelector", "hitRect", "firstPassedTargets", "allowClickBySelectEnd", "hasInsideTargets", "pointTarget", "_findElement", "target", "isPreventSelect", "type", "isTrusted", "result", "isClick", "emit", "startPassedTargets", "_select", "selectFlag", "offsetPos", "calculateMatrixDist", "cssText", "_selectEnd", "isInnerScroll", "inputEvent_1", "innerScrollElement", "parentElement", "body", "overflow", "getComputedStyle", "checkScrollEvent", "dragScroll", "dragStart", "preventDrag", "hasScrollOptions", "isScroll", "drag", "_checkSelected", "isDouble", "isDrag", "isSelect", "dragEnd", "isKeyDown", "_keydownContinueSelect", "_sameCombiKey", "_keydownContinueSelectWithoutDeselection", "keydownContinueSelect", "keydownContinueSelectWithoutDeselection", "isKeyUp", "gesto", "isFlag", "documentElement", "containers", "isNode", "slice", "call", "some", "contains", "document", "initElement", "initDragScroll", "setKeyController", "beforeSelected", "selected", "point1", "point2", "ignoreClick", "selectedElements", "hitTest", "setSelectedTargets", "startPoint", "endPoint", "mousedown", "MouseEvent", "cancelable", "bubbles", "mousemove", "mouseup", "onDragStart", "onDrag", "onDragEnd", "triggerDragStart", "off", "keycon", "destroy", "unset", "injectResult", "removeEvent", "_onDocumentSelectStart", "removeChild", "info", "fitPoints", "selectableElements", "isFunction", "push", "current", "elements", "querySelectorAll", "getEventData", "checkScroll", "getCurrentEvent", "getSelectableElements", "selectablePoints", "getElementPoints", "selectableParentMap", "hasIndexesMap", "parentMap_1", "selectableInnerScrollParentMap", "selectableInnerScrollPathsList", "parents", "paths", "get", "indexes", "prevParentElement", "selectableInners", "_refreshGroups", "dragEvent", "_onDragStart", "_onDragEnd", "KeyController", "keydown", "_onKeyDown", "keyup", "_onKeyUp", "on", "_onBlur", "nextClassName", "setKeyEvent", "preventClickEventByCondition", "preventRightClick", "parentNode", "Gesto", "checkWindowBlur", "_onDrag", "addEvent", "inject", "nonce", "selectRect", "gestoEvent", "innerGroups", "rectPoints", "isHit", "hitRateValue", "splitUnit", "inArea", "isInside", "overlapPoints", "getOverlapPoints", "overlapSize", "getAreaSize", "targetSize", "unit", "rate", "between", "round", "_", "minX", "floor", "maxX", "minY", "maxY", "x", "yGroups", "y", "group", "inner", "next", "direction", "offsetX", "offsetY", "isMoveInnerScroll", "parentMap_2", "parentInfo", "scrollContainer", "containerInfo", "pos", "scrollBy", "isStart", "isDragStartEnd", "startResult", "startSelected", "startAdded", "startRemoved", "isDragStart", "afterAdded", "afterRemoved", "afterPrevList", "afterList", "offsetSize", "passedTargets", "keys", "isKeyup", "combi", "getCombi", "key", "nextKeys", "concat", "toggleKeys", "isArray", "singleKey_1", "every", "innerScrollContainer_1", "parentMap_3", "innerScrollPathsList", "innerScrollPaths", "isAlwaysTrue", "points1", "points2", "selectablePoints_1", "groups_1", "Properties", "prototype", "property", "enumerable", "configurable", "getter", "camelize", "setter", "defineProperty", "EventEmitter", "SelectoManager", "REACT_EVENTS", "EVENTS", "map", "name", "camelize", "Selecto", "__extends", "React", "className", "CLASS_NAME", "ref", "props", "options", "OPTIONS", "forEach", "selecto", "VanillaSelecto", "__assign", "portalContainer", "selectionElement", "i", "_this", "on", "e", "selfProps", "result", "stop", "prevProps", "PROPERTIES", "destroy", "__decorate", "withMethods", "METHODS"]
}
