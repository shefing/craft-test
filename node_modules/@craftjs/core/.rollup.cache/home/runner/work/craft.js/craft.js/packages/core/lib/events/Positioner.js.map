{"version":3,"file":"Positioner.js","sourceRoot":"","sources":["../../src/events/Positioner.ts"],"names":[],"mappings":"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","sourcesContent":["import { getDOMInfo, ROOT_NODE } from '@craftjs/utils';\n\nimport findPosition from './findPosition';\n\nimport { EditorStore } from '../editor/store';\nimport {\n  DragTarget,\n  DropPosition,\n  Indicator,\n  Node,\n  NodeId,\n  NodeInfo,\n  NodeSelectorWrapper,\n} from '../interfaces';\nimport { getNodesFromSelector } from '../utils/getNodesFromSelector';\n\n/**\n * Positioner is responsible for computing the drop Indicator during a sequence of drag-n-drop events\n */\nexport class Positioner {\n  static BORDER_OFFSET = 10;\n\n  // Current Node being hovered on\n  private currentDropTargetId: NodeId | null;\n  // Current closest Canvas Node relative to the currentDropTarget\n  private currentDropTargetCanvasAncestorId: NodeId | null;\n\n  private currentIndicator: Indicator | null = null;\n\n  private currentTargetId: NodeId | null;\n  private currentTargetChildDimensions: NodeInfo[] | null;\n\n  private dragError: string | null;\n  private draggedNodes: NodeSelectorWrapper[];\n\n  private onScrollListener: (e: Event) => void;\n\n  constructor(readonly store: EditorStore, readonly dragTarget: DragTarget) {\n    this.currentDropTargetId = null;\n    this.currentDropTargetCanvasAncestorId = null;\n\n    this.currentTargetId = null;\n    this.currentTargetChildDimensions = null;\n\n    this.currentIndicator = null;\n\n    this.dragError = null;\n    this.draggedNodes = this.getDraggedNodes();\n\n    this.validateDraggedNodes();\n\n    this.onScrollListener = this.onScroll.bind(this);\n    window.addEventListener('scroll', this.onScrollListener, true);\n  }\n\n  cleanup() {\n    window.removeEventListener('scroll', this.onScrollListener, true);\n  }\n\n  private onScroll(e: Event) {\n    const scrollBody = e.target;\n    const rootNode = this.store.query.node(ROOT_NODE).get();\n\n    // Clear the currentTargetChildDimensions if the user has scrolled\n    // Because we will have to recompute new dimensions relative to the new scroll pos\n    const shouldClearChildDimensionsCache =\n      scrollBody instanceof Element &&\n      rootNode &&\n      rootNode.dom &&\n      scrollBody.contains(rootNode.dom);\n\n    if (!shouldClearChildDimensionsCache) {\n      return;\n    }\n\n    this.currentTargetChildDimensions = null;\n  }\n\n  private getDraggedNodes() {\n    if (this.dragTarget.type === 'new') {\n      return getNodesFromSelector(\n        this.store.query.getNodes(),\n        this.dragTarget.tree.nodes[this.dragTarget.tree.rootNodeId]\n      );\n    }\n\n    return getNodesFromSelector(\n      this.store.query.getNodes(),\n      this.dragTarget.nodes\n    );\n  }\n\n  // Check if the elements being dragged are allowed to be dragged\n  private validateDraggedNodes() {\n    // We don't need to check for dragTarget.type = \"new\" because those nodes are not yet in the state (ie: via the .create() connector)\n    if (this.dragTarget.type === 'new') {\n      return;\n    }\n\n    this.draggedNodes.forEach(({ node, exists }) => {\n      if (!exists) {\n        return;\n      }\n\n      this.store.query.node(node.id).isDraggable((err) => {\n        this.dragError = err;\n      });\n    });\n  }\n\n  private isNearBorders(\n    domInfo: ReturnType<typeof getDOMInfo>,\n    x: number,\n    y: number\n  ) {\n    const { top, bottom, left, right } = domInfo;\n\n    if (\n      top + Positioner.BORDER_OFFSET > y ||\n      bottom - Positioner.BORDER_OFFSET < y ||\n      left + Positioner.BORDER_OFFSET > x ||\n      right - Positioner.BORDER_OFFSET < x\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  private isDiff(newPosition: DropPosition) {\n    if (\n      this.currentIndicator &&\n      this.currentIndicator.placement.parent.id === newPosition.parent.id &&\n      this.currentIndicator.placement.index === newPosition.index &&\n      this.currentIndicator.placement.where === newPosition.where\n    ) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Get dimensions of every child Node in the specified parent Node\n   */\n  private getChildDimensions(newParentNode: Node) {\n    // Use previously computed child dimensions if newParentNode is the same as the previous one\n    const existingTargetChildDimensions = this.currentTargetChildDimensions;\n    if (\n      this.currentTargetId === newParentNode.id &&\n      existingTargetChildDimensions\n    ) {\n      return existingTargetChildDimensions;\n    }\n\n    return newParentNode.data.nodes.reduce((result, id: NodeId) => {\n      const dom = this.store.query.node(id).get().dom;\n\n      if (dom) {\n        result.push({\n          id,\n          ...getDOMInfo(dom),\n        });\n      }\n\n      return result;\n    }, [] as NodeInfo[]);\n  }\n\n  /**\n   * Get closest Canvas node relative to the dropTargetId\n   * Return dropTargetId if it itself is a Canvas node\n   *\n   * In most cases it will be the dropTarget itself or its immediate parent.\n   * We typically only need to traverse 2 levels or more if the dropTarget is a linked node\n   *\n   * TODO: We should probably have some special rules to handle linked nodes\n   */\n  private getCanvasAncestor(dropTargetId: NodeId) {\n    // If the dropTargetId is the same as the previous one\n    // Return the canvas ancestor node that we found previuously\n    if (\n      dropTargetId === this.currentDropTargetId &&\n      this.currentDropTargetCanvasAncestorId\n    ) {\n      const node = this.store.query\n        .node(this.currentDropTargetCanvasAncestorId)\n        .get();\n\n      if (node) {\n        return node;\n      }\n    }\n\n    const getCanvas = (nodeId: NodeId): Node => {\n      const node = this.store.query.node(nodeId).get();\n\n      if (node && node.data.isCanvas) {\n        return node;\n      }\n\n      if (!node.data.parent) {\n        return null;\n      }\n\n      return getCanvas(node.data.parent);\n    };\n\n    return getCanvas(dropTargetId);\n  }\n\n  /**\n   * Compute a new Indicator object based on the dropTarget and x,y coords\n   * Returns null if theres no change from the previous Indicator\n   */\n  computeIndicator(dropTargetId: NodeId, x: number, y: number): Indicator {\n    let newParentNode = this.getCanvasAncestor(dropTargetId);\n\n    if (!newParentNode) {\n      return;\n    }\n\n    this.currentDropTargetId = dropTargetId;\n    this.currentDropTargetCanvasAncestorId = newParentNode.id;\n\n    // Get parent if we're hovering at the border of the current node\n    if (\n      newParentNode.data.parent &&\n      this.isNearBorders(getDOMInfo(newParentNode.dom), x, y) &&\n      // Ignore if linked node because there's won't be an adjacent sibling anyway\n      !this.store.query.node(newParentNode.id).isLinkedNode()\n    ) {\n      newParentNode = this.store.query.node(newParentNode.data.parent).get();\n    }\n\n    if (!newParentNode) {\n      return;\n    }\n\n    this.currentTargetChildDimensions = this.getChildDimensions(newParentNode);\n    this.currentTargetId = newParentNode.id;\n\n    const position = findPosition(\n      newParentNode,\n      this.currentTargetChildDimensions,\n      x,\n      y\n    );\n\n    // Ignore if the position is similar as the previous one\n    if (!this.isDiff(position)) {\n      return;\n    }\n\n    let error = this.dragError;\n\n    // Last thing to check for is if the dragged nodes can be dropped in the target area\n    if (!error) {\n      this.store.query.node(newParentNode.id).isDroppable(\n        this.draggedNodes.map((sourceNode) => sourceNode.node),\n        (dropError) => {\n          error = dropError;\n        }\n      );\n    }\n\n    const currentNodeId = newParentNode.data.nodes[position.index];\n    const currentNode =\n      currentNodeId && this.store.query.node(currentNodeId).get();\n\n    this.currentIndicator = {\n      placement: {\n        ...position,\n        currentNode,\n      },\n      error,\n    };\n\n    return this.currentIndicator;\n  }\n\n  getIndicator() {\n    return this.currentIndicator;\n  }\n}\n"]}