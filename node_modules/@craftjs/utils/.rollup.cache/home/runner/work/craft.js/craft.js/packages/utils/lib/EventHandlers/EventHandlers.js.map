{"version":3,"file":"EventHandlers.js","sourceRoot":"","sources":["../../src/EventHandlers/EventHandlers.ts"],"names":[],"mappings":"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","sourcesContent":["import { ConnectorRegistry } from './ConnectorRegistry';\nimport {\n  EventHandlerUpdates,\n  CraftEventListener,\n  EventHandlerConnectors,\n  CraftDOMEvent,\n  Connector,\n  ConnectorsUsage,\n  RegisteredConnector,\n} from './interfaces';\nimport { isEventBlockedByDescendant } from './isEventBlockedByDescendant';\n\nexport abstract class EventHandlers<O extends Record<string, any> = {}> {\n  options: O;\n\n  private registry: ConnectorRegistry = new ConnectorRegistry();\n  private subscribers: Set<(msg: EventHandlerUpdates) => void> = new Set();\n\n  onEnable?(): void;\n  onDisable?(): void;\n\n  constructor(options?: O) {\n    this.options = options;\n  }\n\n  listen(cb: (msg: EventHandlerUpdates) => void) {\n    this.subscribers.add(cb);\n    return () => this.subscribers.delete(cb);\n  }\n\n  disable() {\n    if (this.onDisable) {\n      this.onDisable();\n    }\n\n    this.registry.disable();\n\n    this.subscribers.forEach((listener) => {\n      listener(EventHandlerUpdates.HandlerDisabled);\n    });\n  }\n\n  enable() {\n    if (this.onEnable) {\n      this.onEnable();\n    }\n\n    this.registry.enable();\n\n    this.subscribers.forEach((listener) => {\n      listener(EventHandlerUpdates.HandlerEnabled);\n    });\n  }\n\n  cleanup() {\n    this.disable();\n    this.subscribers.clear();\n    this.registry.clear();\n  }\n\n  addCraftEventListener<K extends keyof HTMLElementEventMap>(\n    el: HTMLElement,\n    eventName: K,\n    listener: CraftEventListener<K>,\n    options?: boolean | AddEventListenerOptions\n  ) {\n    const bindedListener = (e: CraftDOMEvent<HTMLElementEventMap[K]>) => {\n      if (!isEventBlockedByDescendant(e, eventName, el)) {\n        e.craft.stopPropagation = () => {\n          if (!e.craft.blockedEvents[eventName]) {\n            e.craft.blockedEvents[eventName] = [];\n          }\n\n          e.craft.blockedEvents[eventName].push(el);\n        };\n\n        listener(e);\n      }\n    };\n\n    el.addEventListener(eventName, bindedListener, options);\n\n    return () => el.removeEventListener(eventName, bindedListener, options);\n  }\n\n  // Defines the connectors and their logic\n  abstract handlers(): Record<string, (el: HTMLElement, ...args: any[]) => any>;\n\n  /**\n   * Creates a record of chainable connectors and tracks their usages\n   */\n  createConnectorsUsage(): ConnectorsUsage<this> {\n    const handlers = this.handlers();\n\n    // Track all active connector ids here\n    // This is so we can return a cleanup method below so the callee can programmatically cleanup all connectors\n\n    const activeConnectorIds: Set<string> = new Set();\n\n    let canRegisterConnectors = false;\n    const connectorsToRegister: Map<\n      string,\n      () => RegisteredConnector\n    > = new Map();\n\n    const connectors = Object.entries(handlers).reduce<\n      Record<string, Connector>\n    >(\n      (accum, [name, handler]) => ({\n        ...accum,\n        [name]: (el, required, options) => {\n          const registerConnector = () => {\n            const connector = this.registry.register(el, {\n              required,\n              name,\n              options,\n              connector: handler,\n            });\n\n            activeConnectorIds.add(connector.id);\n            return connector;\n          };\n\n          connectorsToRegister.set(\n            this.registry.getConnectorId(el, name),\n            registerConnector\n          );\n\n          /**\n           * If register() has been called,\n           * register the connector immediately.\n           *\n           * Otherwise, registration is deferred until after register() is called\n           */\n          if (canRegisterConnectors) {\n            registerConnector();\n          }\n\n          return el;\n        },\n      }),\n      {}\n    ) as any;\n\n    return {\n      connectors,\n      register: () => {\n        canRegisterConnectors = true;\n\n        connectorsToRegister.forEach((registerConnector) => {\n          registerConnector();\n        });\n      },\n      cleanup: () => {\n        canRegisterConnectors = false;\n\n        activeConnectorIds.forEach((connectorId) =>\n          this.registry.remove(connectorId)\n        );\n      },\n    };\n  }\n\n  derive<C extends EventHandlers>(\n    type: {\n      new (...args: any[]): C;\n    },\n    opts: C['options']\n  ) {\n    return new type(this, opts);\n  }\n\n  // This method allows us to execute multiple connectors and returns a single cleanup method for all of them\n  protected createProxyHandlers<H extends EventHandlers>(\n    instance: H,\n    cb: (connectors: EventHandlerConnectors<H>) => void\n  ) {\n    const connectorsToCleanup = [];\n    const handlers = instance.handlers();\n\n    const proxiedHandlers = new Proxy(handlers, {\n      get: (target, key: any, receiver) => {\n        if (key in handlers === false) {\n          return Reflect.get(target, key, receiver);\n        }\n\n        return (el, ...args) => {\n          const cleanup = handlers[key](el, ...args);\n          if (!cleanup) {\n            return;\n          }\n\n          connectorsToCleanup.push(cleanup);\n        };\n      },\n    });\n\n    cb(proxiedHandlers as any);\n\n    return () => {\n      connectorsToCleanup.forEach((cleanup) => {\n        cleanup();\n      });\n    };\n  }\n\n  // This lets us to execute and cleanup sibling connectors\n  reflect(cb: (connectors: EventHandlerConnectors<this>) => void) {\n    return this.createProxyHandlers(this, cb);\n  }\n}\n"]}